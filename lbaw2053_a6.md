# A6: Indexes, triggers, user functions, transactions and population

The product consists of an online auction website where you are able to bid on and create auctions.
<br/>   
In this artifact, we intend to define the physical schema of our database. We will present a prediction of the database load, create indexes to improve performance and create triggers to assure the integrity of the database whenever certain values in certain tables are inserted, updated or deleted.

## 1. Database Workload
 
> A study of the predicted system load (database load), organized in subsections.  
 
### 1.1. Tuple Estimation
 
> Estimate of tuples at each relation.  

| **Relation reference** | **Relation Name**       | **Order of magnitude**    | **Estimated growth** |
| ---------------------- | ----------------------- | ------------------------- | ----------------- |
| R01                    | auction                 | tens of thousands         | dozens per day    |
| R02                    | bids                    | hundreds of thousands     | hundreds per day  |
| R03                    | notification            | hundreds of thousands     | hundreds per day  |
| R04                    | user                    | thousands                 | dozens per day    |
| R05                    | admin                   | unit                      | no growth         |
| R06                    | buyer                   | thousands                 | dozens per day    |
| R07                    | seller                  | thousands                 | dozens per day    |
| R08                    | block                   | dozens                    | units per day     |
| R09                    | shipping_method         | units                     | no growth         | 
| R10                    | ships                   | tens of thousands         | dozens per day    |
| R11                    | payment_method          | hundreds of thousands     | dozens per day    |
| R12                    | accepts                 | tens of thousands         | dozens per day    |
| R13                    | reports                 | tens of thousands         | units per day     |
| R14                    | report_status           | tens of thousands         | units per day     |
| R15                    | watchlists              | hundreds of thousands     | hundreds per day  |
| R16                    | skill                   | tens                      | no growth         |
| R17                    | features                | hundreds of thousands     | hundreds per day  |
| R18                    | main_color              | tens of thousands         | dozens per day    |
| R19                    | development_stage       | tens of thousands         | dozens per day    | 
| R20                    | category                | tens of thousands         | dozens per day    |
| R21                    | auction_status          | tens of thousands         | dozens per day    | 
| R22                    | image                   | tens of thousands         | dozens per day    |
| R23                    | profile_photo           | thousands                 | dozens per day    |
| R24                    | animal_photo            | hundreds of thousands     | hundreds per day  |


### 1.2. Frequent Queries
 
> Most important queries (SELECT) and their frequency.  

| **Query**       | SELECT01                               |
| ---             | ---                                    |
| **Description** | View User's Profile                    |
| **Frequency**   | hundreds per day                       |
```sql 
SELECT name, email, url
    FROM ("user" NATURAL JOIN profile_photo)
    WHERE "user".email = $email; 
```

| **Query**       | SELECT02                               |
| ---             | ---                                    |
| **Description** | Search for Auctions with Filters       |
| **Frequency**   | thousands per day                      |
```sql 
SELECT id, species_name, current_price, age, ending_date
    FROM (auction JOIN features ON auction.id = features.id_auction)
    WHERE   (id_category = $category OR $category IS NULL)
        AND (id_main_color = $main_color OR $main_color IS NULL)
        AND (id_dev_stage = $dev_stage OR $dev_stage IS NULL)
        AND (current_price < $max_price OR $max_price IS NULL)
        AND (id_skill = $climbs OR $climbs IS NULL)
        AND (id_skill = $jumps OR $jumps IS NULL)
        AND (id_skill = $talks OR $talks IS NULL)
        AND (id_skill = $skates OR $skates IS NULL)
        AND (id_skill = $olfaction OR $olfaction IS NULL)
        AND (id_skill = $navigation OR $navigation IS NULL)
        AND (id_skill = $echo OR $echo IS NULL)
        AND (id_skill = $acrobatics OR $acrobatics IS NULL);
```

| **Query**       | SELECT03                               |
| ---             | ---                                    |
| **Description** | Full Text Search for Auction           |
| **Frequency**   | thousands per day                      |
```sql 
SELECT id, species_name, current_price, age, ending_date, ts_rank_cd(textsearch, query) AS rank
    FROM auction, to_tsquery($search) AS query, 
        to_tsvector(name || ' ' || species_name || ' ' || description) AS textsearch
    WHERE query @@ textsearch\\ 
    ORDER BY rank DESC; 
```

| **Query**       | SELECT04                                        |
| ---             | ---                                             |
| **Description** | Full Text Search for Users in Admin Dashboard   |
| **Frequency**   | dozens per day                                  |
```sql 
SELECT "name", email, ts_rank_cd(textsearch, query) AS rank
    FROM "user", to_tsquery($search) AS query, 
        to_tsvector(name || ' ' || email) AS textsearch
    WHERE query @@ textsearch\\ 
    ORDER BY rank DESC;
```

| **Query**       | SELECT05                               |
| ---             | ---                                    |
| **Description** | Top 3 Auctions for Homepage Display    |
| **Frequency**   | hundreds per day                       |
```sql 
SELECT id, species_name, $current_price, age, ending_date
    FROM (SELECT *, count(*) AS num_bids
            FROM  ((auction JOIN bids ON auction.id = bids.id_auction) JOIN auction_status ON auction.id = auction_status.id_auction)
            WHERE auction_status_name = "Ongoing"
            GROUP BY  auction.id)
    ORDER BY num_bids DESC
    LIMIT 3;
```

| **Query**       | SELECT06                               |
| ---             | ---                                    |
| **Description** | View Notifications                     |
| **Frequency**   | thousands per day                      |
```sql 
SELECT id, message, read
    FROM ("user" JOIN "notification" ON "user".id = "notification".id_buyer)
    WHERE "user".id = $id_user
    ORDER BY id DESC
    LIMIT 5;
```

### 1.3. Frequent Updates

> Most important updates (INSERT, UPDATE, DELETE) and their frequency.  

| **Query**       | INSERT01                               |
| ---             | ---                                    |
| **Description** | Create a New User                      |
| **Frequency**   | dozens per day                         |
```sql 
INSERT INTO "user" (name, email, hashed_password) 
    values ($name, $email, $hashed_password);
```

| **Query**       | INSERT02                               |
| ---             | ---                                    |
| **Description** | Create a New Auction                   |
| **Frequency**   | dozens per day                         |
```sql 
INSERT INTO auction (name, description, species_name, age, starting_price, buyout_price, current_price, ending_date, rating_seller, id_category, id_main_color, id_dev_stage, id_seller)
    values ($name, $description, $species_name, $age, $starting_price, $buyout_price, $current_price, $ending_date, $rating_seller, $id_category, $id_main_color, $id_dev_stage, $id_seller);
```

| **Query**       | INSERT03                               |
| ---             | ---                                    |
| **Description** | Create a New Bid                       |
| **Frequency**   | hundreds per day                       |
```sql 
INSERT INTO bids(value, maximum, id_auction, id_buyer)
    values ($value, $maximum, $id_auction, $id_buyer );
```

| **Query**       | INSERT04                               |
| ---             | ---                                    |
| **Description** | Create a New Notification              |
| **Frequency**   | hundreds per day                       |
```sql 
INSERT INTO "notification" ("message", "type", "read", id_auction, id_buyer)
    values ($message, $type, false, $id_auction, $id_buyer);
```

| **Query**       | INSERT05                               |
| ---             | ---                                    |
| **Description** | Block a new User                       |
| **Frequency**   | units per day                          |
```sql 
INSERT INTO blocks (end_date, id_admin, id_seller)
    values($end_date, $id_admin, $id_seller);
```

| **Query**       | INSERT06                               |
| ---             | ---                                    |
| **Description** | Create a New Report                    |
| **Frequency**   | units per day                         |
```sql 
INSERT INTO reports("date", id_buyer, id_seller)
    values($date, $id_buyer, $id_seller);
```

| **Query**       | INSERT07                               |
| ---             | ---                                    |
| **Description** | Add an auction to the Watchlist        |
| **Frequency**   | hundreds per day                       |
```sql 
INSERT INTO watchlists (id_auction, id_buyer)
    values($id_auction, id_buyer);
```

| **Query**       | INSERT08                               |
| ---             | ---                                    |
| **Description** | Add a Status to a Report               |
| **Frequency**   | units per day                          |
```sql 
INSERT INTO report_status (id, id_reports, TYPE)
    values($id, $id_reports, $report_status);
```

| **Query**       | INSERT09                               |
| ---             | ---                                    |
| **Description** | Add a Status to an Auction             |
| **Frequency**   | dozens per day                         |
```sql 
INSERT INTO auction_status (id, id_auction, TYPE)
    values($id, $id_auction, $auction_status);
```

| **Query**       | UPDATE01                               |
| ---             | ---                                    |
| **Description** | Edit User's Profile                    |
| **Frequency**   | units per day                          |
```sql 
UPDATE "user" 
    SET name=$name, email=$email, hashed_password = $password 
    WHERE id = $id_user
```

| **Query**       | UPDATE02                               |
| ---             | ---                                    |
| **Description** | Edit an Auction                        |
| **Frequency**   | units per day                          |
```sql 
UPDATE auction
    SET name=$name, description=$description, species_name=$species_name, age=$age, starting_price = $starting_price, buyout_price = $buyout_price, ending_date=$ending_date, id_category = $id_category, id_main_color = $id_main_color, id_dev_stage = $id_dev_stage
    WHERE id = $id_auction AND id_seller = $id_seller
```

| **Query**       | UPDATE03                               |
| ---             | ---                                    |
| **Description** | Mark a Notification as read            |
| **Frequency**   | dozens per day                         |
```sql 
UPDATE "notification"
    SET "read" = $read
    WHERE id_auction = $id_auction AND id_buyer = $id_buyer;
```

| **Query**       | UPDATE04                               |
| ---             | ---                                    |
| **Description** | Update an Auction Status               |
| **Frequency**   | dozens per day                         |
```sql 
UPDATE auction_status   
    SET TYPE = $auction_status
    WHERE id = $id;
```

| **Query**       | UPDATE05                               |
| ---             | ---                                    |
| **Description** | Update Report Status                   |
| **Frequency**   | units per day                          |
```sql 
UPDATE report_status   
    SET TYPE = $report_status
    WHERE id=$id;
```

| **Query**       | DELETE01                               |
| ---             | ---                                    |
| **Description** | Delete an Account                      |
| **Frequency**   | units per day                          |
```sql 
DELETE FROM "user"
    WHERE id = $id_user;
```


| **Query**       | DELETE02                               |
| ---             | ---                                    |
| **Description** | Delete an Auction                      |
| **Frequency**   | units per day                          |
```sql 
DELETE FROM auction
    WHERE id = $id_auction;
```

| **Query**       | DELETE03                               |
| ---             | ---                                    |
| **Description** | Remove Auction from Watchlist          |
| **Frequency**   | dozens per day                         |
```sql 
DELETE FROM watchlists  
    WHERE id_auction = $id_auction AND id_buyer = $id_buyer;
```


## 2. Proposed Indices

### 2.1. Performance Indices

> Indices proposed to improve performance of the identified queries.  

| **Index**           | IDX01                                  |
| ---                 | ---                                    |
| **Related queries** | SELECT01                               |
| **Relation**        | user                                   |
| **Attribute**       | email                                  |
| **Type**            | Hash                                   |
| **Cardinality**     | high                                   |
| **Clustering**      | No                                     |
| **Justification**   | Given that this query is executed many times, it's performance is extremely important. An hashed index will allow a linear search through the table. The email attribute has an high cardinality due to the fact that it is a UNIQUE key. For this same reason, no clustering is needed.    |
```sql 
 CREATE INDEX user_email ON "user" USING hash(email); 
```

| **Index**           | IDX02                                  |
| ---                 | ---                                    |
| **Related queries** | SELECT05                               |
| **Relation**        | auction                                |
| **Attribute**       | id                                     |
| **Type**            | Hash                                   |
| **Cardinality**     | high                                   |
| **Clustering**      | No                                     |
| **Justification**   | Given that this query is executed many times, it's performance is extremely important. An hashed index will allow a linear search through the table. The id attribute has an high cardinality due to the fact that it is a PRIMARY key. For this same reason, no clustering is needed.    |
```sql 
 CREATE INDEX auction_id ON auction USING hash(id);
```

| **Index**           | IDX03                                  |
| ---                 | ---                                    |
| **Related queries** | SELECT06                               |
| **Relation**        | notification                           |
| **Attribute**       | id                                     |
| **Type**            | Hash                                   |
| **Cardinality**     | high                                   |
| **Clustering**      | No                                     |
| **Justification**   | Given that this query is executed many times, it's performance is extremely important. An hashed index will allow a linear search through the table. The id attribute has an high cardinality due to the fact that it is a PRIMARY key. For this same reason, no clustering is needed.    |
```sql 
 CREATE INDEX notification_id ON "notifications" USING hash(id);
```

### 2.2. Full-text Search Indices 

> The system being developed must provide full-text search features supported by PostgreSQL. Thus, it is necessary to specify the fields where full-text search will be available and the associated setup, namely all necessary configurations, indexes definitions and other relevant details.  

| **Index**           | IDX01                                  |
| ---                 | ---                                    |
| **Related queries** | SELECT03                               |
| **Relation**        | auction                                |
| **Attribute**       | name                                   |
| **Type**            | GiST                                   |
| **Clustering**      | No                                     |
| **Justification**   | The index type choosen was GiST because it is better than GIN to deal with dynamic data. This index is proposed in order to improve the performance of full text searches while searching for auctions.   |
```sql 
 CREATE INDEX search_auction ON auction USING GIST (to_tsvector('english', name || ' ' || species_name || ' ' || description ))
```
| **Index**           | IDX02                                  |
| ---                 | ---                                    |
| **Related queries** | SELECT04                               |
| **Relation**        | user                                   |
| **Attribute**       | name                                   |
| **Type**            | GiST                                   |
| **Clustering**      | No                                     |
| **Justification**   | The index type choosen was GiST because it is better than GIN to deal with dynamic data. This index is proposed in order to improve the performance of full text searches while searching for users in the admin dashboard.   |
```sql 
 CREATE INDEX admin_search ON "user" USING GIST (to_tsvector('english', name || ' ' || email ))
```

## 3. Triggers
 
> User-defined functions and trigger procedures that add control structures to the SQL language or perform complex computations, are identified and described to be trusted by the database server. Every kind of function (SQL functions, Stored procedures, Trigger procedures) can take base types, composite types, or combinations of these as arguments (parameters). In addition, every kind of function can return a base type or a composite type. Functions can also be defined to return sets of base or composite values.  

| **Trigger**      | TRIGGER01                                   |
| ---              | ---                                         |
| **Description**  | Create Buyer whenever a new User is created |
```sql 
CREATE FUNCTION create_buyer() RETURNS TRIGGER AS
$BODY$
BEGIN
    INSERT INTO buyer(id) values (NEW.id);
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER create_buyer
    AFTER INSERT ON "user" 
    EXECUTE PROCEDURE create_buyer(); 
```

| **Trigger**      | TRIGGER02                                                  |
| ---              | ---                                                        |
| **Description**  | --Create Seller whenever an user creates his first auction |
```sql 
CREATE FUNCTION create_seller() RETURNS TRIGGER AS
$BODY$
BEGIN
    IF NOT EXISTS(SELECT * FROM auction WHERE NEW.id = id)
       THEN INSERT INTO seller(id) values (NEW.id) ;
    END IF;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER create_seller
    AFTER INSERT ON "user" 
    EXECUTE PROCEDURE create_seller(); 
```

| **Trigger**      | TRIGGER03                                          |
| ---              | ---                                                |
| **Description**  | Stop all ongoing auctions when a seller is blocked |
```sql 
CREATE FUNCTION stop_ongoing_auctions() RETURNS TRIGGER AS
$BODY$
BEGIN
    UPDATE auction_status 
        SET TYPE = "Cancelled"
        WHERE id_seller = NEW.id_seller AND TYPE = "Ongoing";
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER stop_ongoing_auctions
    AFTER INSERT ON blocks 
    EXECUTE PROCEDURE stop_ongoing_auctions(); 
```


| **Trigger**      | TRIGGER04                                   |
| ---              | ---                                         |
| **Description**  | Update current price on auction after a bid |
```sql 
CREATE FUNCTION update_current_price() RETURNS TRIGGER AS
$BODY$
BEGIN
    UPDATE auction 
        SET current_price = NEW.value
        WHERE id = NEW.id_auction;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER update_current_price
    AFTER INSERT ON bids 
    EXECUTE PROCEDURE update_current_price(); 
```

| **Trigger**      | TRIGGER05                                               |
| ---              | ---                                                     |
| **Description**  | Send Notification to buyers when their bid is surpassed |
```sql 
CREATE FUNCTION send_notification() RETURNS TRIGGER AS
$BODY$

BEGIN
    SELECT auction_info.id_buyer AS id_winner, auction_info.id_auction AS id_auction , max(auction_info.value)
        FROM (SELECT value, id_auction, id_buyer
              FROM  bids
              WHERE id_auction >= NEW.id_auction) AS auction_info;
        INSERT INTO "notification" ("message", "read", id_auction, id_buyer)
            values("Your bid has been surpassed", FALSE, NEW.id_auction, NEW.id_buyer ); 
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER send_notification
    BEFORE INSERT ON bids 
    EXECUTE PROCEDURE send_notification(); 
```

| **Trigger**      | TRIGGER06                                                       |
| ---              | ---                                                             |
| **Description**  | Send Notification to winner when the status changes to finished |
```sql 
CREATE FUNCTION notify_winner() RETURNS TRIGGER AS
$BODY$
BEGIN
    IF(NEW.TYPE == "Finished")
    THEN
        SELECT auction_info.id_buyer AS id_winner, auction_info.id_auction AS id_auction , max(auction_info.value)
            FROM (SELECT value, id_auction, id_buyer
                    FROM  bids
                    WHERE id_auction >= NEW.id_auction) AS auction_info;
        INSERT INTO "notification" ("message", "read", id_auction, id_buyer)
            VALUES ("You won an auction", FALSE, id_auction, id_winner);
    END IF;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER notify_winner
    AFTER UPDATE ON auction_status 
    EXECUTE PROCEDURE notify_winner(); 
```

| **Trigger**      | TRIGGER07                                                         |
| ---              | ---                                                               |
| **Description**  | Verify if the value of a new bid is greater than the current one  |
```sql 
CREATE FUNCTION verify_bid_value() RETURNS TRIGGER AS
$BODY$
BEGIN
    SELECT current_price FROM auction WHERE NEW.id_auction = id_auction;
    IF (NEW.value <= current_price ) 
        THEN RAISE EXCEPTION 'A bid can only be made with a value greater than the current bid';
    END IF;
    RETURN NEW;
END
$BODY$
LANGUAGE plpgsql;
 
CREATE TRIGGER verify_bid_value
    BEFORE INSERT ON bids
    EXECUTE PROCEDURE verify_bid_value(); 
```

| **Trigger**      | TRIGGER08                                      |
| ---              | ---                                            |
| **Description**  | Update seller's rating when a rating is added  |
```sql 
CREATE FUNCTION update_rating() RETURNS TRIGGER AS
$BODY$
BEGIN
    IF(NEW.TYPE != NULL)
    THEN
        UPDATE seller
        SET rating = (
            SELECT AVG(TYPE)
            FROM auction
            WHERE auction.id = NEW.id
        )
        WHERE seller.id = New.id_seller;
    END IF;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER update_rating
    AFTER UPDATE ON auction 
    EXECUTE PROCEDURE update_rating();  
```

## 4. Transactions
 
> Transactions needed to assure the integrity of the data.  

| SQL Reference   | Select Reports to display in Admin Dashboard    |
| --------------- | -----------------------------------             |
| Justification   | In the middle of the transaction, the insertion of new rows in the auction table can occur, which implies that the information retrieved in both selects is different, consequently resulting in a Phantom Read. It's READ ONLY because it only uses Selects.     |
| Isolation level | SERIALIZABLE READ ONLY                          |
```sql 
BEGIN TRANSACTION;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE READ ONLY
 
SELECT COUNT(*)
    FROM Reports
 
SELECT reports.date, report_status.TYPE, B.name, S.name
    FROM (((reports 
        JOIN report_status ON reports.id = report_status.id_reports) 
        JOIN ((buyer ON reports.id_buyer = buyer.id JOIN "user" ON user.id = buyer.id) AS B))
        JOIN ((seller ON seller.id = reports.id_seller JOIN "user" ON user.id = buyer.id) AS S))
    ORDER BY reports.date DESC
    LIMIT 10;
 
COMMIT;
```


## 5. SQL Code

> The database script must also include the SQL to populate a database with test data with an amount of tuples suitable for testing and with plausible values for the fields of the database.  
> This code should also be included in the group's git repository as an SQL script, and a link include here.  

### 5.1. Database schema

```sql
DROP TABLE IF EXISTS watchlists;
DROP TABLE IF EXISTS ships;
DROP TABLE IF EXISTS profile_photo;
DROP TABLE IF EXISTS features;
DROP TABLE IF EXISTS animal_photo;
DROP TABLE IF EXISTS accepts;
DROP TABLE IF EXISTS skill;
DROP TABLE IF EXISTS report_status;
DROP TABLE IF EXISTS reports;
DROP TABLE IF EXISTS "notification";
DROP TABLE IF EXISTS bids;
DROP TABLE IF EXISTS auction_status;
DROP TABLE IF EXISTS auction;
DROP TABLE IF EXISTS main_color;
DROP TABLE IF EXISTS "image";
DROP TABLE IF EXISTS blocks;
DROP TABLE IF EXISTS development_stage;
DROP TABLE IF EXISTS category;
DROP TABLE IF EXISTS shipping_method;
DROP TABLE IF EXISTS payment_method;
DROP TABLE IF EXISTS "admin";
DROP TABLE IF EXISTS seller;
DROP TABLE IF EXISTS buyer;
DROP TABLE IF EXISTS "user";

DROP TYPE IF EXISTS skill_name;
DROP TYPE IF EXISTS category_name;
DROP TYPE IF EXISTS shipping;
DROP TYPE IF EXISTS rating;
DROP TYPE IF EXISTS payment;
DROP TYPE IF EXISTS dev_stage;
DROP TYPE IF EXISTS color;
DROP TYPE IF EXISTS report_status_name;
DROP TYPE IF EXISTS auction_status_name;

DROP INDEX IF EXISTS user_email;
DROP INDEX IF EXISTS search_auction;
DROP INDEX IF EXISTS admin_search;
DROP INDEX IF EXISTS auction_id;
DROP INDEX IF EXISTS notification_id;

DROP TRIGGER IF EXISTS create_buyer ON "user";
DROP TRIGGER IF EXISTS create_seller ON "user";
DROP TRIGGER IF EXISTS stop_ongoing_auctions ON blocks;
DROP TRIGGER IF EXISTS update_current_price ON bids;
DROP TRIGGER IF EXISTS send_notification ON bids;
DROP TRIGGER IF EXISTS notify_winner ON auction_status;
DROP TRIGGER IF EXISTS verify_bid_value ON bids;
DROP TRIGGER IF EXISTS update_rating ON auction;

DROP FUNCTION IF EXISTS create_buyer();
DROP FUNCTION IF EXISTS create_seller();
DROP FUNCTION IF EXISTS stop_ongoing_auctions();
DROP FUNCTION IF EXISTS update_current_price();
DROP FUNCTION IF EXISTS send_notification();
DROP FUNCTION IF EXISTS notify_winner();
DROP FUNCTION IF EXISTS verify_bid_value();
DROP FUNCTION IF EXISTS update_rating();

-----------------------------------------
-- TYPES
----------------------------------------- 
CREATE TYPE rating AS ENUM ('1', '2', '3', '4', '5');
CREATE TYPE shipping AS ENUM ('Standard Mail', 'Express Mail', 'Urgent Mail');
CREATE TYPE payment AS ENUM ('Debit Card', 'PayPal');
CREATE TYPE skill_name AS ENUM ('Climbs', 'Jumps', 'Talks', 'Skates', 'Olfaction', 'Moonlight Navigation', 'Echolocation', 'Acrobatics');
CREATE TYPE color AS ENUM ('Blue', 'Brown', 'Black', 'Yellow', 'Green', 'Red', 'White');
CREATE TYPE dev_stage AS ENUM ('Baby', 'Child', 'Teen', 'Adult', 'Elderly');
CREATE TYPE category_name AS ENUM ('Mammals', 'Insects', 'Reptiles', 'Fishes', 'Birds', 'Amphibians');
CREATE TYPE report_status_name as ENUM('Pending', 'Approved', 'Denied');
CREATE TYPE auction_status_name as ENUM('Ongoing', 'Cancelled','Finished');

-----------------------------------------
-- TABLES
-----------------------------------------
CREATE TABLE "user"
(
    id SERIAL PRIMARY KEY,
    name text NOT NULL,
    email text NOT NULL UNIQUE,
    hashed_password text NOT NULL
);

CREATE TABLE "admin"
(
    id integer NOT NULL PRIMARY KEY REFERENCES "user" (id) ON UPDATE CASCADE ON DELETE RESTRICT
);

CREATE TABLE buyer
(
    id integer NOT NULL PRIMARY KEY REFERENCES "user" (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE seller
(
    id integer NOT NULL PRIMARY KEY REFERENCES "user" (id) ON UPDATE CASCADE ON DELETE CASCADE,
    rating integer NOT NULL CHECK (rating >= 1 AND rating <= 5)
);

CREATE TABLE skill
(
    id SERIAL PRIMARY KEY,
    TYPE skill_name NOT NULL
);

CREATE TABLE main_color
(
    id SERIAL PRIMARY KEY,
    TYPE color NOT NULL
);

CREATE TABLE development_stage
(
    id SERIAL PRIMARY KEY,
    TYPE dev_stage NOT NULL
);

CREATE TABLE category
(
    id SERIAL PRIMARY KEY,
    TYPE category_name NOT NULL
);

CREATE TABLE payment_method
(
    id SERIAL PRIMARY KEY,
    TYPE payment NOT NULL
);

CREATE TABLE shipping_method
(
    id SERIAL PRIMARY KEY,
    TYPE shipping NOT NULL
);

CREATE TABLE auction
(
    id SERIAL PRIMARY KEY,
    name text NOT NULL,
    description text NOT NULL,
    species_name text NOT NULL,
    age integer NOT NULL,
    starting_price integer NOT NULL,
    buyout_price integer,
    current_price integer,
    ending_date date NOT NULL CHECK (ending_date > 'now'::text::date),
    TYPE rating,
    id_category integer NOT NULL REFERENCES category (id) ON UPDATE CASCADE ON DELETE RESTRICT,
    id_main_color integer NOT NULL REFERENCES main_color (id) ON UPDATE CASCADE ON DELETE RESTRICT,
    id_dev_stage integer NOT NULL REFERENCES development_stage (id) ON UPDATE CASCADE ON DELETE RESTRICT,
    id_payment_method integer REFERENCES payment_method (id) ON UPDATE CASCADE ON DELETE RESTRICT,
    id_shipping_method integer REFERENCES shipping_method (id) ON UPDATE CASCADE ON DELETE RESTRICT,
    id_seller integer NOT NULL REFERENCES seller (id) ON UPDATE CASCADE ,
    id_winner integer REFERENCES buyer (id) ON UPDATE CASCADE ,
    CONSTRAINT "buyout_price_ck" CHECK (buyout_price > starting_price),
    CONSTRAINT "current_price_ck" CHECK (current_price >= starting_price)

);

CREATE TABLE bids
(
    id SERIAL PRIMARY KEY,
    value integer NOT NULL,
    maximum integer,
    id_auction integer NOT NULL REFERENCES auction (id) ON UPDATE CASCADE ON DELETE CASCADE,
    id_buyer integer REFERENCES buyer (id) ON UPDATE CASCADE,
    CONSTRAINT "maximum_ck" CHECK (maximum >= value)
);

CREATE TABLE "notification"
(
    id SERIAL PRIMARY KEY,
    "message" text NOT NULL,
    "read" boolean DEFAULT FALSE,
    id_auction integer NOT NULL REFERENCES auction (id) ON UPDATE CASCADE ON DELETE CASCADE,
    id_buyer integer REFERENCES buyer (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE blocks
(
    id SERIAL PRIMARY KEY,
    end_date date NOT NULL CHECK (end_date > 'now'::text::date),
    id_admin integer NOT NULL REFERENCES "admin" (id) ON UPDATE CASCADE,
    id_seller integer NOT NULL REFERENCES seller (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE ships
(
    id SERIAL PRIMARY KEY,
    id_seller integer NOT NULL REFERENCES seller (id) ON UPDATE CASCADE ON DELETE CASCADE,
    id_shipping_method integer NOT NULL REFERENCES shipping_method (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE accepts
(
    id SERIAL PRIMARY KEY,
    id_seller integer NOT NULL REFERENCES seller (id) ON UPDATE CASCADE ON DELETE CASCADE,
    id_payment_method integer NOT NULL REFERENCES payment_method (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE reports
(
    id SERIAL PRIMARY KEY,
    "date" date NOT NULL DEFAULT 'now'::text::date,
    id_buyer integer NOT NULL REFERENCES buyer (id) ON UPDATE CASCADE,
    id_seller integer NOT NULL REFERENCES seller (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE report_status
(
    id SERIAL PRIMARY KEY,
    id_reports integer NOT NULL REFERENCES reports (id) ON UPDATE CASCADE ON DELETE CASCADE,
    TYPE report_status_name NOT NULL
);

CREATE TABLE watchlists
(
    id SERIAL PRIMARY KEY,
    id_auction integer NOT NULL REFERENCES auction (id) ON UPDATE CASCADE ON DELETE CASCADE,
    id_buyer integer NOT NULL REFERENCES buyer (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE features
(
    id SERIAL PRIMARY KEY,
    id_auction integer NOT NULL REFERENCES auction (id) ON UPDATE CASCADE ON DELETE CASCADE,
    id_skill integer NOT NULL REFERENCES skill (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE auction_status
(
    id SERIAL PRIMARY KEY,
    id_auction integer NOT NULL REFERENCES auction (id) ON UPDATE CASCADE ON DELETE CASCADE,
    TYPE auction_status_name NOT NULL
);

CREATE TABLE "image"
(
    id SERIAL PRIMARY KEY,
    url text NOT NULL
);

CREATE TABLE profile_photo
(
    id integer NOT NULL PRIMARY KEY REFERENCES "image" (id) ON UPDATE CASCADE,
    id_user integer NOT NULL REFERENCES "user" (id) ON UPDATE CASCADE ON DELETE CASCADE
);

CREATE TABLE animal_photo
(
    id integer NOT NULL PRIMARY KEY REFERENCES "image" (id) ON UPDATE CASCADE ,
    id_auction integer NOT NULL REFERENCES auction (id) ON UPDATE CASCADE ON DELETE CASCADE
);

-----------------------------------------
-- INDEXES
-----------------------------------------
CREATE INDEX user_email ON "user" USING hash(email); 

CREATE INDEX search_auction ON auction USING GIST (to_tsvector('english', name || ' ' || species_name || ' ' || description ));

CREATE INDEX admin_search ON "user" USING GIST (to_tsvector('english', name || ' ' || email));

CREATE INDEX auction_id ON auction USING hash(id);

CREATE INDEX notification_id ON "notifications" USING hash(id);

-----------------------------------------
-- TRIGGERS
-----------------------------------------

CREATE FUNCTION create_buyer() RETURNS TRIGGER AS
$BODY$
BEGIN
    INSERT INTO buyer(id) values (NEW.id);
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER create_buyer
    AFTER INSERT ON "user" 
    EXECUTE PROCEDURE create_buyer(); 


CREATE FUNCTION create_seller() RETURNS TRIGGER AS
$BODY$
BEGIN
    IF NOT EXISTS(SELECT * FROM auction WHERE NEW.id = id)
       THEN INSERT INTO seller(id) values (NEW.id) ;
    END IF;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER create_seller
    AFTER INSERT ON "user" 
    EXECUTE PROCEDURE create_seller(); 


CREATE FUNCTION stop_ongoing_auctions() RETURNS TRIGGER AS
$BODY$
BEGIN
    UPDATE auction_status 
        SET TYPE = "Cancelled"
        WHERE id_seller = NEW.id_seller AND TYPE = "Ongoing";
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER stop_ongoing_auctions
    AFTER INSERT ON blocks 
    EXECUTE PROCEDURE stop_ongoing_auctions(); 


CREATE FUNCTION update_current_price() RETURNS TRIGGER AS
$BODY$
BEGIN
    UPDATE auction 
        SET current_price = NEW.value
        WHERE id = NEW.id_auction;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER update_current_price
    AFTER INSERT ON bids 
    EXECUTE PROCEDURE update_current_price(); 


CREATE FUNCTION send_notification() RETURNS TRIGGER AS
$BODY$

BEGIN
    SELECT auction_info.id_buyer AS id_winner, auction_info.id_auction AS id_auction , max(auction_info.value)
        FROM (SELECT value, id_auction, id_buyer
              FROM  bids
              WHERE id_auction >= NEW.id_auction) AS auction_info;
        INSERT INTO "notification" ("message", "read", id_auction, id_buyer)
            values("Your bid has been surpassed", FALSE, NEW.id_auction, NEW.id_buyer ); 
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER send_notification
    BEFORE INSERT ON bids 
    EXECUTE PROCEDURE send_notification(); 


CREATE FUNCTION notify_winner() RETURNS TRIGGER AS
$BODY$
BEGIN
    IF(NEW.TYPE == "Finished")
    THEN
        SELECT auction_info.id_buyer AS id_winner, auction_info.id_auction AS id_auction , max(auction_info.value)
            FROM (SELECT value, id_auction, id_buyer
                    FROM  bids
                    WHERE id_auction >= NEW.id_auction) AS auction_info;
        INSERT INTO "notification" ("message", "read", id_auction, id_buyer)
            VALUES ("You won an auction", FALSE, id_auction, id_winner);
    END IF;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER notify_winner
    AFTER UPDATE ON auction_status 
    EXECUTE PROCEDURE notify_winner(); 


CREATE FUNCTION verify_bid_value() RETURNS TRIGGER AS
$BODY$
BEGIN
    SELECT current_price FROM auction WHERE NEW.id_auction = id_auction;
    IF (NEW.value <= current_price ) 
        THEN RAISE EXCEPTION 'A bid can only be made with a value greater than the current bid';
    END IF;
    RETURN NEW;
END
$BODY$
LANGUAGE plpgsql;
 
CREATE TRIGGER verify_bid_value
    BEFORE INSERT ON bids
    EXECUTE PROCEDURE verify_bid_value();


CREATE FUNCTION update_rating() RETURNS TRIGGER AS
$BODY$
BEGIN
    IF(NEW.TYPE != NULL)
    THEN
        UPDATE seller
        SET rating = (
            SELECT AVG(TYPE)
            FROM auction
            WHERE auction.id = NEW.id
        )
        WHERE seller.id = New.id_seller;
    END IF;
END
$BODY$
LANGUAGE plpgsql;

CREATE TRIGGER update_rating
    AFTER UPDATE ON auction 
    EXECUTE PROCEDURE update_rating(); 
```

### 5.2. Database population

## Revision history

No changes were made yet

***
GROUP2053, 30/03/2020

* Carlos Miguel Sousa Vieira, up201606868@fe.up.pt
* João Alberto Preto Rodrigues Praça, up201704748@fe.up.pt 
* Lucas Tomás Martins Ribeiro, up201705227@fe.up.pt
* Silvia Jorge Moreira da Rocha, up201704684@fe.up.pt (Editor)